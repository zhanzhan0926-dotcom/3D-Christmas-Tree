<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å®‡å®™æ˜Ÿæ²³åœ£è¯æ ‘ - å¯æ—‹è½¬ç¼©æ”¾æ·»åŠ ç…§ç‰‡</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            overflow: hidden;
            background: radial-gradient(ellipse at center, #1a1a3e 0%, #0a0e27 100%);
            font-family: 'Arial', sans-serif;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            border-radius: 15px;
            font-size: 14px;
            z-index: 1000;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 215, 0, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            max-width: 320px;
        }
        
        #info h2 {
            margin-bottom: 15px;
            color: #ffcc00;
            font-size: 22px;
            text-shadow: 0 0 10px rgba(255, 204, 0, 0.5);
        }
        
        #info p {
            margin: 8px 0;
            line-height: 1.8;
            display: flex;
            align-items: center;
        }
        
        #info .icon {
            margin-right: 10px;
            font-size: 18px;
        }
        
        #controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 30px;
            border-radius: 50px;
            display: flex;
            gap: 20px;
            z-index: 1000;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 255, 255, 0.2);
        }
        
        #controls button {
            padding: 10px 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }
        
        #controls button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }
        
        #controls button:active {
            transform: translateY(0);
        }
        
        #zoomLevel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 20px;
            border-radius: 10px;
            color: #4fc3f7;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            z-index: 1000;
        }
        
        .photo-frame {
            position: absolute;
            width: 60px;
            height: 60px;
            border: 3px solid gold;
            border-radius: 50%;
            overflow: hidden;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.6);
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            color: gold;
            font-size: 24px;
        }
        
        .photo-frame:hover {
            transform: scale(1.2);
            box-shadow: 0 0 30px rgba(255, 215, 0, 1);
        }
        
        .photo-frame img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        #fileInput {
            display: none;
        }
        
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 12px;
            pointer-events: none;
            z-index: 10000;
            display: none;
            white-space: nowrap;
        }
        
        /* æ˜Ÿç©ºèƒŒæ™¯ */
        .stars {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        .star {
            position: absolute;
            width: 2px;
            height: 2px;
            background: white;
            border-radius: 50%;
            animation: twinkle 3s infinite;
        }
        
        @keyframes twinkle {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }
    </style>
</head>
<body>
    <div id="container"></div>
    
    <div class="stars" id="stars"></div>
    
    <div id="info">
        <h2>ğŸ„ å®‡å®™æ˜Ÿæ²³åœ£è¯æ ‘</h2>
        <p><span class="icon">ğŸ–±ï¸</span><strong>æ‹–æ‹½</strong> æ—‹è½¬åœ£è¯æ ‘</p>
        <p><span class="icon">ğŸ”</span><strong>æ»šè½®</strong> ç¼©æ”¾è§†è§’</p>
        <p><span class="icon">ğŸ“·</span><strong>ç‚¹å‡»å½©çƒ</strong> æ·»åŠ ç…§ç‰‡</p>
        <p><span class="icon">âœ¨</span><strong>é è¿‘</strong> æ¨åŠ¨ç²’å­</p>
        <p id="status" style="color: #4fc3f7; margin-top: 10px; border-top: 1px solid rgba(255,255,255,0.2); padding-top: 10px;">
            <span class="icon">âœ…</span>å°±ç»ª
        </p>
    </div>
    
    <div id="zoomLevel">
        ç¼©æ”¾: <span id="zoomValue">100</span>%<br>
        ç…§ç‰‡: <span id="photoCount">0</span>/20
    </div>
    
    <div id="controls">
        <button onclick="resetView()">ğŸ”„ é‡ç½®è§†è§’</button>
        <button onclick="autoRotate = !autoRotate">
            <span id="rotateIcon">â¸ï¸</span> è‡ªåŠ¨æ—‹è½¬
        </button>
        <button onclick="toggleGalaxyMode()">
            <span id="galaxyIcon">ğŸŒŒ</span> æ˜Ÿæ²³æ¨¡å¼
        </button>
    </div>
    
    <input type="file" id="fileInput" accept="image/*">
    <div class="tooltip" id="tooltip"></div>
    
    <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.158.0/examples/js/controls/OrbitControls.js"></script>
    
    <script>
    // ==================== æ£€æŸ¥ Three.js ====================
    if (typeof THREE === 'undefined') {
        alert('Three.js åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œ');
        throw new Error('Three.js åŠ è½½å¤±è´¥');
    }
    
    // ==================== åœºæ™¯åˆå§‹åŒ– ====================
    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x0a0e27, 20, 80);
    
    const camera = new THREE.PerspectiveCamera(
        50, 
        window.innerWidth / window.innerHeight, 
        0.1, 
        1000
    );
    
    const renderer = new THREE.WebGLRenderer({ 
        antialias: true, 
        alpha: true 
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.getElementById('container').appendChild(renderer.domElement);

    camera.position.set(0, 8, 25);
    camera.lookAt(0, 5, 0);

    // ==================== è½¨é“æ§åˆ¶å™¨ ====================
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.minDistance = 5;
    controls.maxDistance = 50;
    controls.target.set(0, 5, 0);
    controls.enablePan = false;

    let autoRotate = true;
    controls.autoRotate = true;
    controls.autoRotateSpeed = 2;

    // ç›‘å¬ç¼©æ”¾å˜åŒ–
    controls.addEventListener('change', () => {
        const distance = camera.position.distanceTo(controls.target);
        const zoomPercent = Math.round((50 - distance) / 45 * 100 + 100);
        document.getElementById('zoomValue').textContent = Math.max(0, zoomPercent);
        
        // æ ¹æ®ç¼©æ”¾è°ƒæ•´é›¾æ•ˆå’Œç²’å­å¤§å°
        scene.fog.near = distance * 0.8;
        scene.fog.far = distance * 3;
        
        if (treePoints) {
            treePoints.material.size = 0.1 + (50 - distance) / 200;
        }
    });

    // ==================== å…‰ç…§ç³»ç»Ÿ ====================
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(ambientLight);

    const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
    mainLight.position.set(5, 15, 10);
    scene.add(mainLight);

    // å½©è‰²ç‚¹å…‰æºï¼ˆå¢å¼ºæ°›å›´ï¼‰
    const colorLights = [
        { color: 0xff0099, pos: [8, 6, 0] },
        { color: 0x00ff99, pos: [-8, 6, 0] },
        { color: 0x0099ff, pos: [0, 6, 8] },
        { color: 0xffcc00, pos: [0, 6, -8] }
    ];

    colorLights.forEach(({ color, pos }) => {
        const light = new THREE.PointLight(color, 1.5, 30);
        light.position.set(...pos);
        scene.add(light);
    });

    // ==================== ç²’å­åœ£è¯æ ‘ ====================
    const treeParticles = [];
    let treePoints;

    function createGalaxyTree() {
        const treeLayers = [
            { yStart: 0, yEnd: 1.5, radiusTop: 0.4, radiusBottom: 0.5, color: 0x8B4513, density: 150 },
            { yStart: 1.5, yEnd: 3.0, radiusTop: 2.5, radiusBottom: 3.0, color: 0x0d4d0d, density: 600 },
            { yStart: 3.0, yEnd: 4.5, radiusTop: 2.0, radiusBottom: 2.5, color: 0x0f5f0f, density: 500 },
            { yStart: 4.5, yEnd: 6.0, radiusTop: 1.5, radiusBottom: 2.0, color: 0x1a7a1a, density: 400 },
            { yStart: 6.0, yEnd: 7.5, radiusTop: 1.0, radiusBottom: 1.5, color: 0x228b22, density: 350 },
            { yStart: 7.5, yEnd: 9.0, radiusTop: 0.5, radiusBottom: 1.0, color: 0x2d962d, density: 250 },
            { yStart: 9.0, yEnd: 10.0, radiusTop: 0.2, radiusBottom: 0.5, color: 0x32cd32, density: 150 }
        ];

        const geometry = new THREE.BufferGeometry();
        const positions = [];
        const colors = [];
        const sizes = [];

        treeLayers.forEach(layer => {
            const layerHeight = layer.yEnd - layer.yStart;
            
            for (let i = 0; i < layer.density; i++) {
                const t = Math.random();
                const y = layer.yStart + t * layerHeight;
                const radius = layer.radiusBottom + (layer.radiusTop - layer.radiusBottom) * t;
                
                // èºæ—‹åˆ†å¸ƒï¼ˆæ›´è‡ªç„¶ï¼‰
                const spiralAngle = (y / 10) * Math.PI * 6 + Math.random() * 0.5;
                const angle = spiralAngle + Math.random() * Math.PI * 2;
                const r = Math.pow(Math.random(), 0.7) * radius;
                
                const x = Math.cos(angle) * r;
                const z = Math.sin(angle) * r;
                
                positions.push(x, y, z);
                
                const color = new THREE.Color(layer.color);
                // æ·»åŠ éšæœºå‘å…‰æ•ˆæœ
                if (Math.random() > 0.9) {
                    color.offsetHSL(0, 0.3, 0.3);
                }
                colors.push(color.r, color.g, color.b);
                
                sizes.push(0.08 + Math.random() * 0.07);
                
                treeParticles.push({
                    original: new THREE.Vector3(x, y, z),
                    velocity: new THREE.Vector3(0, 0, 0),
                    angle: angle
                });
            }
        });

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

        const material = new THREE.PointsMaterial({
            size: 0.1,
            vertexColors: true,
            transparent: true,
            opacity: 0.85,
            blending: THREE.AdditiveBlending,
            sizeAttenuation: true
        });

        const points = new THREE.Points(geometry, material);
        scene.add(points);
        return points;
    }

    treePoints = createGalaxyTree();

    // ==================== è£…é¥°ç‰©ç³»ç»Ÿ ====================
    const ornaments = [];
    const photoFrames = [];
    let currentOrnament = null;

    function createPhotoOrnament(position, color, index) {
        const geometry = new THREE.SphereGeometry(0.3, 32, 32);
        const material = new THREE.MeshStandardMaterial({
            color: color,
            metalness: 0.9,
            roughness: 0.1,
            emissive: color,
            emissiveIntensity: 0.5
        });
        
        const ornament = new THREE.Mesh(geometry, material);
        ornament.position.copy(position);
        ornament.castShadow = true;
        ornament.userData = {
            index: index,
            originalColor: color,
            hasPhoto: false,
            floatOffset: Math.random() * Math.PI * 2
        };
        
        scene.add(ornament);
        ornaments.push(ornament);
        return ornament;
    }

    function createStar(position) {
        const shape = new THREE.Shape();
        for (let i = 0; i < 10; i++) {
            const angle = (i / 10) * Math.PI * 2 - Math.PI / 2;
            const radius = i % 2 === 0 ? 0.6 : 0.24;
            const x = Math.cos(angle) * radius;
            const y = Math.sin(angle) * radius;
            if (i === 0) shape.moveTo(x, y);
            else shape.lineTo(x, y);
        }

        const geometry = new THREE.ExtrudeGeometry(shape, { depth: 0.15, bevelEnabled: true, bevelThickness: 0.02 });
        const material = new THREE.MeshStandardMaterial({
            color: 0xffff00,
            emissive: 0xffaa00,
            emissiveIntensity: 1.5,
            metalness: 1
        });

        const star = new THREE.Mesh(geometry, material);
        star.position.copy(position);
        
        const pointLight = new THREE.PointLight(0xffff00, 3, 8);
        pointLight.position.copy(position);
        scene.add(pointLight);
        star.userData.light = pointLight;
        
        scene.add(star);
        return star;
    }

    // æ·»åŠ è£…é¥°ç‰©
    const topStar = createStar(new THREE.Vector3(0, 10.5, 0));
    const ballColors = [0xff0000, 0x0000ff, 0xffd700, 0xff69b4, 0x00ff00, 0xff8c00, 0x9c27b0, 0x00bcd4];

    for (let i = 0; i < 20; i++) {
        const layer = 2.5 + Math.random() * 6;
        const maxRadius = (10 - layer) / 3.5;
        const angle = (i / 20) * Math.PI * 2 + Math.random() * 0.5;
        const radius = maxRadius * (0.5 + Math.random() * 0.5);
        
        const pos = new THREE.Vector3(
            Math.cos(angle) * radius,
            layer,
            Math.sin(angle) * radius
        );
        
        const color = ballColors[i % ballColors.length];
        createPhotoOrnament(pos, color, i);
    }

    // ==================== é¼ æ ‡äº¤äº’ ====================
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    const mouseWorld = new THREE.Vector3();
    let isMouseDown = false;

    // é¼ æ ‡ç§»åŠ¨ - ç²’å­äº¤äº’
    renderer.domElement.addEventListener('mousemove', (event) => {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(ornaments);
        
        // é‡ç½®æ‰€æœ‰è£…é¥°ç‰©
        ornaments.forEach(orb => {
            if (!orb.userData.hasPhoto) {
                orb.scale.set(1, 1, 1);
                orb.material.emissiveIntensity = 0.5;
            }
        });
        
        // é«˜äº®æ‚¬åœçš„è£…é¥°ç‰©
        if (intersects.length > 0) {
            const hoveredOrb = intersects[0].object;
            hoveredOrb.scale.set(1.3, 1.3, 1.3);
            hoveredOrb.material.emissiveIntensity = 1;
            
            const tooltip = document.getElementById('tooltip');
            tooltip.style.display = 'block';
            tooltip.style.left = event.clientX + 15 + 'px';
            tooltip.style.top = event.clientY + 15 + 'px';
            tooltip.textContent = hoveredOrb.userData.hasPhoto ? 'æŸ¥çœ‹ç…§ç‰‡' : 'ç‚¹å‡»æ·»åŠ ç…§ç‰‡';
            renderer.domElement.style.cursor = 'pointer';
        } else {
            document.getElementById('tooltip').style.display = 'none';
            renderer.domElement.style.cursor = 'grab';
        }
        
        // è®¡ç®—é¼ æ ‡åœ¨3Dç©ºé—´çš„ä½ç½®ï¼ˆç”¨äºç²’å­äº¤äº’ï¼‰
        const vector = new THREE.Vector3(mouse.x, mouse.y, 0.5);
        vector.unproject(camera);
        const dir = vector.sub(camera.position).normalize();
        const distance = -camera.position.z / dir.z;
        mouseWorld.copy(camera.position).add(dir.multiplyScalar(distance));
    });

    // ç‚¹å‡»è£…é¥°ç‰©ä¸Šä¼ ç…§ç‰‡
    renderer.domElement.addEventListener('click', (event) => {
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(ornaments);
        
        if (intersects.length > 0) {
            currentOrnament = intersects[0].object;
            document.getElementById('fileInput').click();
        }
    });

    // å¤„ç†æ–‡ä»¶ä¸Šä¼ 
    document.getElementById('fileInput').addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (file && currentOrnament) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const textureLoader = new THREE.TextureLoader();
                textureLoader.load(e.target.result, (texture) => {
                    currentOrnament.material.map = texture;
                    currentOrnament.material.emissiveMap = texture;
                    currentOrnament.material.needsUpdate = true;
                    currentOrnament.userData.hasPhoto = true;
                    
                    const photoCount = ornaments.filter(o => o.userData.hasPhoto).length;
                    document.getElementById('photoCount').textContent = photoCount;
                });
            };
            reader.readAsDataURL(file);
        }
        event.target.value = '';
    });

    renderer.domElement.addEventListener('mousedown', () => {
        isMouseDown = true;
        controls.autoRotate = false;
        renderer.domElement.style.cursor = 'grabbing';
    });

    renderer.domElement.addEventListener('mouseup', () => {
        isMouseDown = false;
        controls.autoRotate = autoRotate;
        renderer.domElement.style.cursor = 'grab';
    });

    // ==================== ç²’å­ç‰©ç† ====================
    function updateParticles() {
        const positions = treePoints.geometry.attributes.position.array;
        const time = Date.now() * 0.0001;
        
        for (let i = 0; i < treeParticles.length; i++) {
            const particle = treeParticles[i];
            const index = i * 3;
            
            const current = new THREE.Vector3(
                positions[index],
                positions[index + 1],
                positions[index + 2]
            );
            
            // é¼ æ ‡æ’æ–¥åŠ›
            const worldCurrent = current.clone().applyMatrix4(treePoints.matrixWorld);
            const distance = worldCurrent.distanceTo(mouseWorld);
            
            if (distance < 3 && !isMouseDown) {
                const force = worldCurrent.sub(mouseWorld)
                    .normalize()
                    .multiplyScalar(0.5 / Math.max(distance, 0.2));
                particle.velocity.add(force);
            }
            
            // è½»å¾®çš„èºæ—‹åŠ¨ç”»
            const spiralForce = new THREE.Vector3(
                Math.cos(particle.angle + time) * 0.002,
                0,
                Math.sin(particle.angle + time) * 0.002
            );
            particle.velocity.add(spiralForce);
            
            // æ¢å¤åŠ›
            const restore = particle.original.clone()
                .sub(current)
                .multiplyScalar(0.05);
            
            particle.velocity.add(restore);
            particle.velocity.multiplyScalar(0.92);
            
            current.add(particle.velocity);
            
            positions[index] = current.x;
            positions[index + 1] = current.y;
            positions[index + 2] = current.z;
        }
        
        treePoints.geometry.attributes.position.needsUpdate = true;
    }

    // ==================== æ˜Ÿç©ºèƒŒæ™¯ ====================
    const starsContainer = document.getElementById('stars');
    for (let i = 0; i < 100; i++) {
        const star = document.createElement('div');
        star.className = 'star';
        star.style.left = Math.random() * 100 + '%';
        star.style.top = Math.random() * 100 + '%';
        star.style.animationDelay = Math.random() * 3 + 's';
        starsContainer.appendChild(star);
    }

    // ==================== æ˜Ÿæ²³æ¨¡å¼ ====================
    let galaxyMode = false;
    function toggleGalaxyMode() {
        galaxyMode = !galaxyMode;
        document.getElementById('galaxyIcon').textContent = galaxyMode ? 'ğŸ„' : 'ğŸŒŒ';
        
        if (galaxyMode) {
            scene.fog.density = 0;
            treePoints.material.opacity = 0.4;
            treePoints.material.size = 0.15;
            camera.position.set(0, 5, 10);
        } else {
            scene.fog.density = 0.02;
            treePoints.material.opacity = 0.85;
            treePoints.material.size = 0.1;
            camera.position.set(0, 8, 25);
        }
    }

    // ==================== æ§åˆ¶å‡½æ•° ====================
    function resetView() {
        camera.position.set(0, 8, 25);
        controls.target.set(0, 5, 0);
        controls.update();
    }

    // ==================== åŠ¨ç”»å¾ªç¯ ====================
    const clock = new THREE.Clock();
    
    function animate() {
        requestAnimationFrame(animate);
        const time = clock.getElapsedTime();
        
        updateParticles();
        controls.update();
        
        // è£…é¥°ç‰©åŠ¨ç”»
        ornaments.forEach((orb, i) => {
            const offset = orb.userData.floatOffset;
            orb.position.y += Math.sin(time * 1.5 + offset) * 0.001;
            orb.rotation.y += 0.01;
        });
        
        // æ˜Ÿæ˜Ÿé—ªçƒ
        if (topStar.userData.light) {
            topStar.rotation.y = time * 0.5;
            topStar.userData.light.intensity = 3 + Math.sin(time * 4) * 0.5;
        }
        
        renderer.render(scene, camera);
    }

    // æ›´æ–°è‡ªåŠ¨æ—‹è½¬æŒ‰é’®
    setInterval(() => {
        document.getElementById('rotateIcon').textContent = autoRotate ? 'â¸ï¸' : 'â–¶ï¸';
    }, 100);

    animate();

    // ==================== å“åº”å¼ ====================
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
    
    console.log('âœ… å®‡å®™æ˜Ÿæ²³åœ£è¯æ ‘åŠ è½½å®Œæˆï¼');
    </script>
</body>
</html>
