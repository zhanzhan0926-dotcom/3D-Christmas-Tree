<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Magical 3D Christmas Tree</title>
    <style> 
        body { margin: 0; overflow: hidden; background-color: #050505; } 
    </style>
    <!-- å¼•å…¥ Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>
</head>
<body>
    <script type="module">
        import * as THREE from 'three';

        // --- 1. åœºæ™¯åˆå§‹åŒ– ---
        const scene = new THREE.Scene();
        // æ·»åŠ è¿·é›¾ï¼Œè®©è¿œå¤„çš„æ˜Ÿæ˜Ÿå˜æš—ï¼Œå¢åŠ æ·±é‚ƒæ„Ÿ
        scene.fog = new THREE.FogExp2(0x050505, 0.02);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 15;
        camera.position.y = 2; // ç¨å¾®æ”¾ä½è§†è§’ï¼Œä»°è§†æ›´æœ‰æ„Ÿè§‰

        const renderer = new THREE.WebGLRenderer({ antialias: true }); // å¼€å¯æŠ—é”¯é½¿
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio); // é€‚é…æ‰‹æœºé«˜æ¸…å±
        document.body.appendChild(renderer.domElement);

        // --- 2. æ ¸å¿ƒç´ æå‡†å¤‡ ---
        // åŠ è½½ä¸€ä¸ªå‘å…‰çš„ç²’å­è´´å›¾ï¼Œè¿™æ­¥æ˜¯å‘Šåˆ«"æ–¹å—"çš„å…³é”®
        const loader = new THREE.TextureLoader();
        // ä½¿ç”¨ Three.js å®˜æ–¹ç¤ºä¾‹çš„ä¸€ä¸ªå…‰ç‚¹è´´å›¾
        const particleTexture = loader.load('https://threejs.org/examples/textures/sprites/spark1.png');

        // --- 3. åˆ¶ä½œåœ£è¯æ ‘ (Tree) ---
        const treeGeometry = new THREE.BufferGeometry();
        const treeCount = 10000; // å¢åŠ ç²’å­æ•°é‡ï¼Œæ›´èŒ‚å¯†
        
        const treePositions = [];
        const treeColors = [];
        const treeSizes = [];
        const treeExtras = []; // ç”¨äºå­˜å‚¨æ¯ä¸ªç‚¹çš„éšæœºå‚æ•°ï¼Œåšé—ªçƒåŠ¨ç”»

        const colorObj = new THREE.Color();

        for (let i = 0; i < treeCount; i++) {
            // æ•°å­¦é€»è¾‘ä¼˜åŒ–ï¼šæ›´è‡ªç„¶çš„åœ†é”¥èºæ—‹
            const angle = Math.random() * Math.PI * 2 * 50; // èºæ—‹åœˆæ•°
            const radius = Math.random() * 6; // åº•éƒ¨åŠå¾„
            const height = (15 - radius * 2.5) + Math.random(); // åŠå¾„è¶Šå°é«˜åº¦è¶Šé«˜

            // è½¬åŒ–ä¸ºåæ ‡
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;
            const y = height - 8; // å‚ç›´å±…ä¸­

            treePositions.push(x, y, z);

            // é¢œè‰²é­”æ³•ï¼šæ··åˆç»¿è‰²ã€é‡‘è‰²ã€çº¢è‰²ã€è“è‰²
            const colorType = Math.random();
            if (colorType > 0.9) {
                colorObj.setHex(0xff0000); // 10% çº¢è‰²è£…é¥°çƒ
            } else if (colorType > 0.8) {
                colorObj.setHex(0xffd700); // 10% é‡‘è‰²è£…é¥°çƒ
            } else if (colorType > 0.7) {
                colorObj.setHex(0xffffff); // 10% é“¶è‰²é›ªèŠ±
            } else {
                // 70% æ¸å˜ç»¿ (é’ç»¿ -> æ·±ç»¿)
                colorObj.setHSL(0.3 + Math.random() * 0.1, 0.8, 0.5); 
            }
            treeColors.push(colorObj.r, colorObj.g, colorObj.b);

            // å¤§å°éšæœºï¼šè£…é¥°çƒå¤§ä¸€ç‚¹ï¼Œæ ‘å¶å°ä¸€ç‚¹
            treeSizes.push(Math.random() * 0.5 + 0.1);
            
            // éšæœºé—ªçƒå‚æ•° (phase, speed)
            treeExtras.push(Math.random() * Math.PI * 2, Math.random() * 2 + 0.5); 
        }

        treeGeometry.setAttribute('position', new THREE.Float32BufferAttribute(treePositions, 3));
        treeGeometry.setAttribute('color', new THREE.Float32BufferAttribute(treeColors, 3));
        treeGeometry.setAttribute('size', new THREE.Float32BufferAttribute(treeSizes, 1));
        treeGeometry.setAttribute('extra', new THREE.Float32BufferAttribute(treeExtras, 2));

        // æ ¸å¿ƒæè´¨å‡çº§ï¼šä½¿ç”¨ Shader (ç€è‰²å™¨) çš„ç®€åŒ–ç‰ˆæˆ–è‡ªå®šä¹‰å±æ€§
        // è¿™é‡Œä¸ºäº†ç®€å•ä¸”æ•ˆæœå¥½ï¼Œæˆ‘ä»¬ä½¿ç”¨ PointsMaterial é…åˆè´´å›¾
        const treeMaterial = new THREE.PointsMaterial({
            size: 0.5, // å…¨å±€åŸºå‡†å¤§å°
            map: particleTexture, // è´´å›¾ï¼
            vertexColors: true, // å¯ç”¨é¡¶ç‚¹é¢œè‰²
            blending: THREE.AdditiveBlending, // ğŸŒŸ å åŠ å‘å…‰æ¨¡å¼ï¼å…³é”®ï¼
            depthWrite: false, // é˜²æ­¢ç²’å­ç›¸äº’é®æŒ¡äº§ç”Ÿé»‘è¾¹
            transparent: true,
            opacity: 0.8
        });

        const tree = new THREE.Points(treeGeometry, treeMaterial);
        scene.add(tree);


        // --- 4. åˆ¶ä½œèƒŒæ™¯æ˜Ÿç©º (Galaxy) ---
        const starsGeometry = new THREE.BufferGeometry();
        const starsCount = 2000;
        const starsPos = [];
        
        for(let i=0; i<starsCount; i++) {
            const x = (Math.random() - 0.5) * 80;
            const y = (Math.random() - 0.5) * 80;
            const z = (Math.random() - 0.5) * 80;
            starsPos.push(x, y, z);
        }
        starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsPos, 3));
        
        const starsMaterial = new THREE.PointsMaterial({
            size: 0.3,
            map: particleTexture,
            transparent: true,
            opacity: 0.4,
            blending: THREE.AdditiveBlending,
            color: 0xffffff
        });
        
        const stars = new THREE.Points(starsGeometry, starsMaterial);
        scene.add(stars);


        // --- 5. åŠ¨ç”»å¾ªç¯ ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            // æ ‘çš„æ—‹è½¬
            tree.rotation.y -= 0.003;
            
            // èƒŒæ™¯æ˜Ÿæ˜Ÿç¼“æ…¢ç§»åŠ¨
            stars.rotation.y -= 0.0005;

            // --- è¿™é‡Œçš„é€»è¾‘è®©æ ‘â€œæ´»â€è¿‡æ¥ ---
            // æˆ‘ä»¬æ— æ³•ç›´æ¥åœ¨ CPU é‡Œé«˜æ•ˆä¿®æ”¹æ¯ä¸€ä¸ªç‚¹çš„å¤§å°ï¼ˆä¼šå¡ï¼‰ï¼Œ
            // ä½†æˆ‘ä»¬å¯ä»¥é€šè¿‡ç®€å•çš„æ•´ä½“ç¼©æ”¾æ¨¡æ‹Ÿâ€œå‘¼å¸â€
            // æˆ–è€…è®©ç›¸æœºå¾®å¾®æµ®åŠ¨
            
            camera.position.y += Math.sin(time) * 0.002;
            camera.position.x += Math.cos(time * 0.5) * 0.002;

            renderer.render(scene, camera);
        }

        animate();

        // çª—å£é€‚é…
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // --- äº¤äº’ï¼šé¼ æ ‡/è§¦æ‘¸ç§»åŠ¨æ”¹å˜è§†è§’ ---
        let mouseX = 0;
        let mouseY = 0;
        let targetX = 0;
        let targetY = 0;
        
        const windowHalfX = window.innerWidth / 2;
        const windowHalfY = window.innerHeight / 2;
        
        document.addEventListener('mousemove', (event) => {
             mouseX = (event.clientX - windowHalfX);
             mouseY = (event.clientY - windowHalfY);
        });

        // åœ¨ animate ä¸­æ·»åŠ ï¼š
        // camera.position.x += (mouseX * 0.005 - camera.position.x) * 0.05;
        // camera.position.y += (-mouseY * 0.005 - camera.position.y) * 0.05;
        // camera.lookAt(scene.position);
        
    </script>
</body>
</html>
