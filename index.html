<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D ç²’å­åœ£è¯æ ‘ - åˆ†å±‚åŠ å¼ºç‰ˆ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1a3e 50%, #0f3460 100%);
            font-family: 'Arial', sans-serif;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }
        
        #video {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 200px;
            height: 150px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            object-fit: cover;
            z-index: 1000;
        }
        
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border-radius: 10px;
            font-size: 14px;
            z-index: 1000;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            max-width: 300px;
        }
        
        #info h2 {
            margin-bottom: 10px;
            color: #ffcc00;
            font-size: 18px;
        }
        
        #info p {
            margin: 5px 0;
            line-height: 1.5;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            z-index: 999;
            text-align: center;
        }
        
        .loading::after {
            content: '...';
            animation: dots 1.5s infinite;
        }
        
        @keyframes dots {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60%, 100% { content: '...'; }
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <video id="video" autoplay playsinline muted></video>
    
    <div id="info">
        <h2>ğŸ„ æ‰‹åŠ¿æ§åˆ¶è¯´æ˜</h2>
        <p>ğŸ‘† ä¼¸å‡ºé£ŸæŒ‡é è¿‘å±å¹•</p>
        <p>ğŸŒŠ ç§»åŠ¨æ‰‹æŒ‡æ¨åŠ¨ç²’å­</p>
        <p>âœ¨ è§‚å¯Ÿè£…é¥°ç‰©åŠ¨ç”»</p>
        <p id="status">æ­£åœ¨å¯åŠ¨æ‘„åƒå¤´...</p>
    </div>
    
    <div class="loading" id="loading">åŠ è½½ä¸­</div>
    
    <!-- å¼•å…¥ Three.js -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
    
    <!-- å¼•å…¥ MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/hands.min.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1620248357/camera_utils.min.js" crossorigin="anonymous"></script>
    
    <script>
    // ==================== åœºæ™¯åˆå§‹åŒ– ====================
    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x0a0e27, 10, 50);
    
    const camera = new THREE.PerspectiveCamera(
        60, 
        window.innerWidth / window.innerHeight, 
        0.1, 
        1000
    );
    
    const renderer = new THREE.WebGLRenderer({ 
        antialias: true, 
        alpha: true 
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.getElementById('container').appendChild(renderer.domElement);

    camera.position.set(0, 6, 18);
    camera.lookAt(0, 5, 0);

    // ==================== å…‰ç…§ç³»ç»Ÿ ====================
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
    scene.add(ambientLight);

    const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
    mainLight.position.set(5, 15, 10);
    mainLight.castShadow = true;
    mainLight.shadow.mapSize.width = 2048;
    mainLight.shadow.mapSize.height = 2048;
    scene.add(mainLight);

    // å½©è‰²èšå…‰ç¯ï¼ˆè¥é€ èŠ‚æ—¥æ°›å›´ï¼‰
    const spotLightColors = [
        { color: 0xff0000, pos: [8, 5, 0] },
        { color: 0x00ff00, pos: [-8, 5, 0] },
        { color: 0x0000ff, pos: [0, 5, 8] },
        { color: 0xffff00, pos: [0, 5, -8] }
    ];

    spotLightColors.forEach(({ color, pos }) => {
        const light = new THREE.SpotLight(color, 0.6, 50, Math.PI / 6);
        light.position.set(...pos);
        light.target.position.set(0, 3, 0);
        scene.add(light);
        scene.add(light.target);
    });

    // ==================== ç²’å­åœ£è¯æ ‘ ====================
    const treeParticles = [];
    const particleCount = 3500;

    function createEnhancedTree() {
        // å®šä¹‰æ ‘çš„åˆ†å±‚ç»“æ„ï¼ˆæ›´çœŸå®çš„åœ£è¯æ ‘å½¢çŠ¶ï¼‰
        const treeLayers = [
            // æ ‘å¹²
            { yStart: 0, yEnd: 1.5, radiusTop: 0.4, radiusBottom: 0.5, color: 0x8B4513, density: 200 },
            // åº•å±‚ï¼ˆæœ€å®½ï¼‰
            { yStart: 1.5, yEnd: 3.5, radiusTop: 2.5, radiusBottom: 3.2, color: 0x0d4d0d, density: 800 },
            // ä¸­åº•å±‚
            { yStart: 3.5, yEnd: 5.0, radiusTop: 2.0, radiusBottom: 2.5, color: 0x0f5f0f, density: 600 },
            // ä¸­å±‚
            { yStart: 5.0, yEnd: 6.5, radiusTop: 1.5, radiusBottom: 2.0, color: 0x1a7a1a, density: 500 },
            // ä¸­ä¸Šå±‚
            { yStart: 6.5, yEnd: 8.0, radiusTop: 1.0, radiusBottom: 1.5, color: 0x228b22, density: 400 },
            // é¡¶å±‚
            { yStart: 8.0, yEnd: 9.5, radiusTop: 0.3, radiusBottom: 1.0, color: 0x2d962d, density: 300 }
        ];

        const geometry = new THREE.BufferGeometry();
        const positions = [];
        const colors = [];
        const sizes = [];

        treeLayers.forEach(layer => {
            const layerHeight = layer.yEnd - layer.yStart;
            
            for (let i = 0; i < layer.density; i++) {
                // åœ¨å±‚å†…éšæœºåˆ†å¸ƒ
                const t = Math.random();
                const y = layer.yStart + t * layerHeight;
                const radius = layer.radiusBottom + (layer.radiusTop - layer.radiusBottom) * t;
                
                // æ·»åŠ ä¸€äº›éšæœºæ€§ï¼Œè®©æ ‘æ›´è‡ªç„¶
                const angle = Math.random() * Math.PI * 2;
                const r = Math.random() * radius;
                const x = Math.cos(angle) * r;
                const z = Math.sin(angle) * r;
                
                positions.push(x, y, z);
                
                // é¢œè‰²æ¸å˜
                const color = new THREE.Color(layer.color);
                color.offsetHSL(0, 0, (Math.random() - 0.5) * 0.1);
                colors.push(color.r, color.g, color.b);
                
                // ç²’å­å¤§å°å˜åŒ–
                sizes.push(0.08 + Math.random() * 0.05);
                
                treeParticles.push({
                    original: new THREE.Vector3(x, y, z),
                    velocity: new THREE.Vector3(0, 0, 0)
                });
            }
        });

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

        const material = new THREE.PointsMaterial({
            size: 0.1,
            vertexColors: true,
            transparent: true,
            opacity: 0.9,
            blending: THREE.AdditiveBlending,
            sizeAttenuation: true
        });

        const points = new THREE.Points(geometry, material);
        scene.add(points);
        return points;
    }

    const treePoints = createEnhancedTree();

    // ==================== è£…é¥°ç‰©ç³»ç»Ÿ ====================
    const decorations = [];

    // åˆ›å»ºå½©çƒ
    function createOrnament(position, color, size = 0.25) {
        const geometry = new THREE.SphereGeometry(size, 16, 16);
        const material = new THREE.MeshStandardMaterial({
            color: color,
            metalness: 0.9,
            roughness: 0.1,
            emissive: color,
            emissiveIntensity: 0.4
        });
        const ornament = new THREE.Mesh(geometry, material);
        ornament.position.copy(position);
        ornament.castShadow = true;
        ornament.userData.floatOffset = Math.random() * Math.PI * 2;
        scene.add(ornament);
        return ornament;
    }

    // åˆ›å»ºäº”è§’æ˜Ÿ
    function createStar(position, size = 0.5) {
        const shape = new THREE.Shape();
        for (let i = 0; i < 10; i++) {
            const angle = (i / 10) * Math.PI * 2 - Math.PI / 2;
            const radius = i % 2 === 0 ? size : size * 0.4;
            const x = Math.cos(angle) * radius;
            const y = Math.sin(angle) * radius;
            if (i === 0) shape.moveTo(x, y);
            else shape.lineTo(x, y);
        }

        const extrudeSettings = { depth: 0.15, bevelEnabled: true, bevelThickness: 0.02 };
        const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
        const material = new THREE.MeshStandardMaterial({
            color: 0xffff00,
            emissive: 0xffaa00,
            emissiveIntensity: 1,
            metalness: 1,
            roughness: 0
        });

        const star = new THREE.Mesh(geometry, material);
        star.position.copy(position);
        star.castShadow = true;
        scene.add(star);
        
        // æ·»åŠ å‘å…‰æ•ˆæœ
        const pointLight = new THREE.PointLight(0xffff00, 2, 5);
        pointLight.position.copy(position);
        scene.add(pointLight);
        star.userData.light = pointLight;
        
        return star;
    }

    // åˆ›å»ºé“ƒé“›
    function createBell(position) {
        const group = new THREE.Group();
        
        const bodyGeo = new THREE.CylinderGeometry(0.12, 0.18, 0.25, 16, 1, true);
        const bodyMat = new THREE.MeshStandardMaterial({
            color: 0xFFD700,
            metalness: 0.95,
            roughness: 0.05
        });
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        
        const topGeo = new THREE.SphereGeometry(0.06, 16, 16);
        const top = new THREE.Mesh(topGeo, bodyMat);
        top.position.y = 0.15;
        
        const clapperGeo = new THREE.SphereGeometry(0.04, 8, 8);
        const clapper = new THREE.Mesh(clapperGeo, bodyMat);
        clapper.position.y = -0.08;
        
        group.add(body, top, clapper);
        group.position.copy(position);
        group.castShadow = true;
        group.userData.swingOffset = Math.random() * Math.PI * 2;
        scene.add(group);
        return group;
    }

    // åˆ›å»ºè´è¶ç»“
    function createBow(position) {
        const group = new THREE.Group();
        const material = new THREE.MeshStandardMaterial({
            color: 0xff1744,
            metalness: 0.2,
            roughness: 0.8
        });

        // å·¦å³è´è¶ç»“ç¿¼
        const wingGeo = new THREE.TorusGeometry(0.18, 0.07, 12, 24, Math.PI);
        
        const leftWing = new THREE.Mesh(wingGeo, material);
        leftWing.rotation.y = Math.PI / 2;
        leftWing.rotation.z = -Math.PI / 6;
        leftWing.position.set(-0.12, 0, 0);
        
        const rightWing = new THREE.Mesh(wingGeo, material);
        rightWing.rotation.y = -Math.PI / 2;
        rightWing.rotation.z = Math.PI / 6;
        rightWing.position.set(0.12, 0, 0);
        
        // ä¸­å¿ƒç»“
        const centerGeo = new THREE.SphereGeometry(0.08, 16, 16);
        const center = new THREE.Mesh(centerGeo, material);
        
        // ä¸å¸¦
        const ribbonGeo = new THREE.BoxGeometry(0.04, 0.3, 0.04);
        const ribbon1 = new THREE.Mesh(ribbonGeo, material);
        ribbon1.position.y = -0.15;
        ribbon1.rotation.z = 0.2;
        
        const ribbon2 = new THREE.Mesh(ribbonGeo, material);
        ribbon2.position.y = -0.15;
        ribbon2.rotation.z = -0.2;
        
        group.add(leftWing, rightWing, center, ribbon1, ribbon2);
        group.position.copy(position);
        group.castShadow = true;
        scene.add(group);
        return group;
    }

    // æ·»åŠ æ‰€æœ‰è£…é¥°ç‰©
    function addAllDecorations() {
        // é¡¶éƒ¨å¤§æ˜Ÿæ˜Ÿ
        const topStar = createStar(new THREE.Vector3(0, 10, 0), 0.6);
        decorations.push(topStar);

        // å½©çƒåˆ†å¸ƒ
        const ballColors = [0xff0000, 0x0000ff, 0xffd700, 0xff69b4, 0x00ff00, 0xff8c00];
        for (let i = 0; i < 18; i++) {
            const layer = 2.5 + Math.random() * 6;
            const maxRadius = (10 - layer) / 3.5;
            const angle = (i / 18) * Math.PI * 2 + Math.random() * 0.5;
            const radius = maxRadius * (0.6 + Math.random() * 0.4);
            
            const pos = new THREE.Vector3(
                Math.cos(angle) * radius,
                layer,
                Math.sin(angle) * radius
            );
            const color = ballColors[Math.floor(Math.random() * ballColors.length)];
            decorations.push(createOrnament(pos, color, 0.2 + Math.random() * 0.15));
        }

        // é“ƒé“›
        for (let i = 0; i < 8; i++) {
            const layer = 3 + Math.random() * 5;
            const maxRadius = (10 - layer) / 3.5;
            const angle = (i / 8) * Math.PI * 2;
            const radius = maxRadius * 0.7;
            
            const pos = new THREE.Vector3(
                Math.cos(angle) * radius,
                layer,
                Math.sin(angle) * radius
            );
            decorations.push(createBell(pos));
        }

        // è´è¶ç»“
        for (let i = 0; i < 10; i++) {
            const layer = 2.5 + Math.random() * 6;
            const maxRadius = (10 - layer) / 3.5;
            const angle = (i / 10) * Math.PI * 2 + 0.3;
            const radius = maxRadius * 0.8;
            
            const pos = new THREE.Vector3(
                Math.cos(angle) * radius,
                layer,
                Math.sin(angle) * radius
            );
            decorations.push(createBow(pos));
        }
    }

    addAllDecorations();

    // ==================== æ‰‹åŠ¿è¯†åˆ« ====================
    let handPosition = new THREE.Vector3(0, 5, 5);
    let isHandDetected = false;

    const handIndicator = new THREE.Mesh(
        new THREE.SphereGeometry(0.3, 32, 32),
        new THREE.MeshBasicMaterial({
            color: 0xff00ff,
            transparent: true,
            opacity: 0.6,
            blending: THREE.AdditiveBlending
        })
    );
    handIndicator.visible = false;
    scene.add(handIndicator);

    // MediaPipe Hands åˆå§‹åŒ–
    const hands = new Hands({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1646424915/${file}`
    });

    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.7,
        minTrackingConfidence: 0.5
    });

    hands.onResults(onHandResults);

    function onHandResults(results) {
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            const indexTip = landmarks[8];
            
            handPosition.set(
                (0.5 - indexTip.x) * 25,
                (1 - indexTip.y) * 18 - 2,
                5
            );
            
            isHandDetected = true;
            handIndicator.visible = true;
            document.getElementById('status').textContent = 'âœ… æ‰‹åŠ¿å·²è¯†åˆ«';
        } else {
            isHandDetected = false;
            handIndicator.visible = false;
            document.getElementById('status').textContent = 'â³ ç­‰å¾…æ‰‹åŠ¿...';
        }
    }

    // å¯åŠ¨æ‘„åƒå¤´
    const videoElement = document.getElementById('video');
    const camera_util = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({ image: videoElement });
        },
        width: 640,
        height: 480
    });

    camera_util.start().then(() => {
        document.getElementById('loading').style.display = 'none';
        console.log('æ‘„åƒå¤´å¯åŠ¨æˆåŠŸ');
    }).catch(err => {
        console.error('æ‘„åƒå¤´å¯åŠ¨å¤±è´¥:', err);
        document.getElementById('status').textContent = 'âŒ æ‘„åƒå¤´æƒé™è¢«æ‹’ç»';
    });

    // ==================== ç²’å­äº¤äº’ ====================
    function updateParticles() {
        const positions = treePoints.geometry.attributes.position.array;
        
        for (let i = 0; i < treeParticles.length; i++) {
            const particle = treeParticles[i];
            const index = i * 3;
            
            const current = new THREE.Vector3(
                positions[index],
                positions[index + 1],
                positions[index + 2]
            );
            
            if (isHandDetected) {
                const distance = current.distanceTo(handPosition);
                
                if (distance < 4) {
                    const force = new THREE.Vector3()
                        .subVectors(current, handPosition)
                        .normalize()
                        .multiplyScalar(0.4 / Math.max(distance, 0.3));
                    
                    particle.velocity.add(force);
                }
            }
            
            // æ¢å¤åŠ›
            const restore = new THREE.Vector3()
                .subVectors(particle.original, current)
                .multiplyScalar(0.06);
            
            particle.velocity.add(restore);
            particle.velocity.multiplyScalar(0.90);
            
            current.add(particle.velocity);
            
            positions[index] = current.x;
            positions[index + 1] = current.y;
            positions[index + 2] = current.z;
        }
        
        treePoints.geometry.attributes.position.needsUpdate = true;
    }

    // ==================== åŠ¨ç”»å¾ªç¯ ====================
    const clock = new THREE.Clock();
    
    function animate() {
        requestAnimationFrame(animate);
        const time = clock.getElapsedTime();
        
        updateParticles();
        
        if (isHandDetected) {
            handIndicator.position.copy(handPosition);
            handIndicator.scale.setScalar(1 + Math.sin(time * 5) * 0.2);
        }
        
        // è£…é¥°ç‰©åŠ¨ç”»
        decorations.forEach((dec, i) => {
            if (dec.userData.light) {
                // æ˜Ÿæ˜Ÿé—ªçƒ
                dec.rotation.y = time * 0.5;
                dec.userData.light.intensity = 2 + Math.sin(time * 3) * 0.5;
            } else if (dec.userData.floatOffset !== undefined) {
                // å½©çƒæ¼‚æµ®
                const offset = dec.userData.floatOffset;
                dec.position.y += Math.sin(time * 2 + offset) * 0.001;
                dec.rotation.y += 0.01;
            } else if (dec.userData.swingOffset !== undefined) {
                // é“ƒé“›æ‘†åŠ¨
                const offset = dec.userData.swingOffset;
                dec.rotation.z = Math.sin(time * 2 + offset) * 0.1;
            } else {
                // è´è¶ç»“æ—‹è½¬
                dec.rotation.y = time * 0.3 + i;
            }
        });
        
        // æ ‘ç¼“æ…¢æ—‹è½¬
        treePoints.rotation.y = time * 0.05;
        
        renderer.render(scene, camera);
    }

    animate();

    // ==================== å“åº”å¼ ====================
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
    </script>
</body>
</html>
