<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>3D Particle Tree</title>
    <style> body { margin: 0; overflow: hidden; background-color: #000; } </style>
    <!-- 引入 Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
            }
        }
    </script>
</head>
<body>
    <script type="module">
        import * as THREE from 'three';

        // 1. 创建场景、相机、渲染器
        const scene = new THREE.Scene();
        // 添加一点雾气效果，让远处粒子变暗
        scene.fog = new THREE.FogExp2(0x000000, 0.05); 

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 20; // 相机后退一点，看到全貌
        camera.position.y = 5;

        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // 2. 生成粒子圣诞树的核心逻辑
        const geometry = new THREE.BufferGeometry();
        const count = 3000; // 粒子数量
        const positions = [];
        const colors = [];
        
        // 这里的颜色用 RGB 表示
        const colorObj = new THREE.Color(); 

        for (let i = 0; i < count; i++) {
            // --- 数学魔法区域 ---
            
            // 高度 y：从 0 到 15
            const y = Math.random() * 15; 
            
            // 半径 r：随着高度变高，半径变小（圆锥体形状）
            // 公式：r = (15 - y) * 0.5
            const radius = (15 - y) * 0.5; 
            
            // 角度 phi：螺旋上升
            const angle = y * 5 + Math.random() * Math.PI * 2;

            // 转化为笛卡尔坐标
            const x = Math.cos(angle) * radius;
            const z = Math.sin(angle) * radius;

            positions.push(x, y - 7.5, z); // y - 7.5 是为了让树垂直居中

            // 设置颜色：基于高度渐变（绿色到黄色）
            colorObj.setHSL(y / 15 * 0.3 + 0.2, 1.0, 0.5);
            colors.push(colorObj.r, colorObj.g, colorObj.b);
        }

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

        // 3. 材质：让粒子发光
        const material = new THREE.PointsMaterial({
            size: 0.2,
            vertexColors: true, // 使用我们计算的颜色
            blending: THREE.AdditiveBlending, // 叠加混合模式（发光感）
            depthWrite: false,
            transparent: true
        });

        const tree = new THREE.Points(geometry, material);
        scene.add(tree);

        // 4. 动画循环
        function animate() {
            requestAnimationFrame(animate);

            // 让树自己慢慢旋转
            tree.rotation.y -= 0.005;

            renderer.render(scene, camera);
        }

        animate();

        // 窗口大小调整处理
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
