<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>3D 粒子圣诞树 - 分层加强版</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: white;
            font-family: sans-serif;
            pointer-events: none;
            z-index: 10;
            text-shadow: 0 0 5px #ff0000;
        }
    </style>
</head>
<body>
    <div id="info">移动鼠标 / 滑动屏幕 来旋转圣诞树</div>

    <!-- 引入 Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- 1. 场景初始化 ---
        const scene = new THREE.Scene();
        // 添加一点背景雾气，增加深邃感
        scene.fog = new THREE.FogExp2(0x050505, 0.02);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 10, 25);
        camera.lookAt(0, 5, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // --- 2. 核心数学逻辑：生成分层树 ---
        const treeGroup = new THREE.Group();
        scene.add(treeGroup);

        // 参数设置
        const particleCount = 15000; // 粒子总数
        const treeHeight = 20;       // 树高
        const baseRadius = 8;        // 底部半径
        const layers = 8;            // 树的层数（决定像不像松树）

        // 几何体与材质
        const geometry = new THREE.BufferGeometry();
        const positions = [];
        const colors = [];

        // 颜色库
        const colorInside = new THREE.Color('#0f4d19'); // 内部深绿
        const colorOutside = new THREE.Color('#42f56c'); // 外部亮绿
        const colorSnow = new THREE.Color('#ffffff');    // 树梢积雪

        for (let i = 0; i < particleCount; i++) {
            // y: 高度比例 0 -> 1
            const y = Math.random(); 
            const heightPos = y * treeHeight;

            // --- 核心数学公式修改 ---
            // 原始圆锥半径
            let r = baseRadius * (1 - y);
            
            // 添加分层波动 (Sine Wave)
            // 使用 Math.pow 让底部波动小，顶部波动大，或者反之
            const layerWave = Math.sin(y * layers * Math.PI) * 0.5; 
            // 这是一个塑形函数，让树看起来像塔状
            // 如果是在层的"凹陷"处，半径缩小；在"凸起"处，半径正常
            // 这里做一个复杂的映射让树枝向下垂
            const layerFactor = 1 + (Math.sin(y * layers * Math.PI * 2) * 0.2); 
            
            // 最终半径：结合线性衰减和层级波动，并加入随机分布填满内部
            const finalRadius = r * layerFactor * Math.sqrt(Math.random());

            // 螺旋角度
            const angle = y * 25 + Math.random() * Math.PI * 2;

            const x = Math.cos(angle) * finalRadius;
            const z = Math.sin(angle) * finalRadius;

            positions.push(x, heightPos - treeHeight / 2, z);

            // --- 颜色处理 ---
            // 根据粒子距离轴心的远近来染色
            // 归一化距离
            const distanceRatio = finalRadius / (r * layerFactor);
            
            const mixedColor = colorInside.clone();
            if (distanceRatio > 0.8) {
                // 树梢亮绿
                mixedColor.lerp(colorOutside, 0.8);
            } 
            if (distanceRatio > 0.95) {
                // 最外层加点雪白
                mixedColor.lerp(colorSnow, 0.6);
            }

            colors.push(mixedColor.r, mixedColor.g, mixedColor.b);
        }

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

        // 粒子材质：使用圆形贴图模拟光点
        const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/disc.png');
        const material = new THREE.PointsMaterial({
            size: 0.25,
            vertexColors: true,
            map: sprite,
            alphaTest: 0.5,
            transparent: true,
            blending: THREE.AdditiveBlending, // 发光混合模式
            opacity: 0.9
        });

        const treeMesh = new THREE.Points(geometry, material);
        treeGroup.add(treeMesh);

        // --- 3. 装饰品生成逻辑 ---
        const decorationGroup = new THREE.Group();
        treeGroup.add(decorationGroup);

        const berryGeo = new THREE.SphereGeometry(0.15, 8, 8);
        const berryMat = new THREE.MeshBasicMaterial({ color: 0xff0000 }); // 红果子

        const bellGeo = new THREE.ConeGeometry(0.2, 0.3, 4); 
        const bellMat = new THREE.MeshBasicMaterial({ color: 0xffd700 }); // 金铃铛

        // 在树的表面随机挂装饰品
        for(let i=0; i<300; i++) {
            const y = Math.random();
            // 只在树枝末端挂东西 (0.85 ~ 1.0 的半径位置)
            const rBase = baseRadius * (1 - y);
            const layerFactor = 1 + (Math.sin(y * layers * Math.PI * 2) * 0.2); 
            const r = rBase * layerFactor;

            const angle = Math.random() * Math.PI * 2;
            const x = Math.cos(angle) * r;
            const z = Math.sin(angle) * r;
            const h = y * treeHeight - treeHeight / 2;

            const isBell = Math.random() > 0.7; // 30%概率是铃铛
            const mesh = new THREE.Mesh(isBell ? bellGeo : berryGeo, isBell ? bellMat : berryMat);
            
            mesh.position.set(x, h, z);
            decorationGroup.add(mesh);
        }

        // 顶部星星
        const starGeo = new THREE.OctahedronGeometry(0.8, 0);
        const starMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
        const star = new THREE.Mesh(starGeo, starMat);
        star.position.set(0, treeHeight / 2 + 0.5, 0);
        treeGroup.add(star);


        // --- 4. 交互控制 (模拟手势) ---
        let targetRotation = 0;
        let mouseX = 0;

        document.addEventListener('mousemove', (event) => {
            // 将鼠标 X 坐标映射到 -1 到 1
            mouseX = (event.clientX / window.innerWidth) * 2 - 1;
            // 映射目标旋转角度 (例如 -180度 到 180度)
            targetRotation = mouseX * Math.PI;
        });
        
        // 触摸屏支持
        document.addEventListener('touchmove', (event) => {
             if(event.touches.length > 0) {
                 mouseX = (event.touches[0].clientX / window.innerWidth) * 2 - 1;
                 targetRotation = mouseX * Math.PI;
             }
        });

        // --- 5. 动画循环 ---
        function animate() {
            requestAnimationFrame(animate);

            // 1. 树的自转 (缓慢自动 + 鼠标控制)
            // 使用 lerp (线性插值) 让旋转有惯性，感觉更像手势控制
            treeGroup.rotation.y += (targetRotation - treeGroup.rotation.y) * 0.05;
            
            // 2. 装饰品闪烁/摆动
            const time = Date.now() * 0.001;
            star.rotation.y = time; // 星星自转
            star.scale.setScalar(1 + Math.sin(time * 3) * 0.1); // 星星忽大忽小

            // 3. 粒子闪烁动画 (通过更新颜色或大小，这里为了性能暂略，仅做整体微动)
            
            renderer.render(scene, camera);
        }

        // 窗口大小调整
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
