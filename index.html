<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D ç²’å­åœ£è¯æ ‘ - é¼ æ ‡äº¤äº’ç‰ˆ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1a3e 50%, #0f3460 100%);
            font-family: 'Arial', sans-serif;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
            cursor: none; /* éšè—é¼ æ ‡ï¼Œæ˜¾ç¤ºè‡ªå®šä¹‰æŒ‡ç¤ºå™¨ */
        }
        
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border-radius: 15px;
            font-size: 14px;
            z-index: 1000;
            backdrop-filter: blur(10px);
            border: 2px solid rgba(255, 215, 0, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            max-width: 280px;
        }
        
        #info h2 {
            margin-bottom: 12px;
            color: #ffcc00;
            font-size: 20px;
            text-shadow: 0 0 10px rgba(255, 204, 0, 0.5);
        }
        
        #info p {
            margin: 8px 0;
            line-height: 1.6;
        }
        
        #stats {
            position: absolute;
            top: 20px;
            right: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.7);
            color: #4fc3f7;
            border-radius: 10px;
            font-size: 12px;
            z-index: 1000;
            font-family: 'Courier New', monospace;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 28px;
            z-index: 999;
            text-align: center;
            font-weight: bold;
        }
        
        .loading::after {
            content: '...';
            animation: dots 1.5s infinite;
        }
        
        @keyframes dots {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60%, 100% { content: '...'; }
        }
        
        #customCursor {
            position: fixed;
            width: 30px;
            height: 30px;
            border: 2px solid #ff00ff;
            border-radius: 50%;
            pointer-events: none;
            z-index: 10000;
            box-shadow: 0 0 20px #ff00ff;
            transition: transform 0.1s ease;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    
    <div id="customCursor"></div>
    
    <div id="info">
        <h2>ğŸ„ åœ£è¯æ ‘äº¤äº’</h2>
        <p>ğŸ–±ï¸ <strong>ç§»åŠ¨é¼ æ ‡</strong> æ¨åŠ¨ç²’å­</p>
        <p>âœ¨ è§‚å¯Ÿè£…é¥°ç‰©åŠ¨ç”»</p>
        <p>ğŸŒˆ æ¬£èµå½©è‰²ç¯å…‰æ•ˆæœ</p>
        <p id="status" style="color: #4fc3f7; margin-top: 10px;">âœ… å°±ç»ª</p>
    </div>
    
    <div id="stats">
        FPS: <span id="fps">60</span><br>
        ç²’å­æ•°: <span id="particles">3500</span><br>
        è£…é¥°ç‰©: <span id="decorations">37</span>
    </div>
    
    <div class="loading" id="loading">åŠ è½½ä¸­</div>
    
    <!-- åªéœ€è¦ Three.jsï¼Œæ— éœ€ MediaPipe -->
    <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
    
    <script>
    // ==================== æ£€æŸ¥ Three.js åŠ è½½ ====================
    if (typeof THREE === 'undefined') {
        document.getElementById('loading').innerHTML = 
            'âŒ Three.js åŠ è½½å¤±è´¥<br><small style="font-size:16px;">è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥</small>';
        throw new Error('Three.js åŠ è½½å¤±è´¥');
    }
    
    console.log('âœ… Three.js åŠ è½½æˆåŠŸ');
    
    // ==================== åœºæ™¯åˆå§‹åŒ– ====================
    const scene = new THREE.Scene();
    scene.fog = new THREE.Fog(0x0a0e27, 10, 50);
    
    const camera = new THREE.PerspectiveCamera(
        60, 
        window.innerWidth / window.innerHeight, 
        0.1, 
        1000
    );
    
    const renderer = new THREE.WebGLRenderer({ 
        antialias: true, 
        alpha: true 
    });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    document.getElementById('container').appendChild(renderer.domElement);

    camera.position.set(0, 6, 18);
    camera.lookAt(0, 5, 0);

    // ==================== å…‰ç…§ç³»ç»Ÿ ====================
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
    scene.add(ambientLight);

    const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
    mainLight.position.set(5, 15, 10);
    mainLight.castShadow = true;
    scene.add(mainLight);

    // å½©è‰²èšå…‰ç¯
    const spotLightColors = [
        { color: 0xff0000, pos: [8, 5, 0] },
        { color: 0x00ff00, pos: [-8, 5, 0] },
        { color: 0x0000ff, pos: [0, 5, 8] },
        { color: 0xffff00, pos: [0, 5, -8] }
    ];

    spotLightColors.forEach(({ color, pos }) => {
        const light = new THREE.SpotLight(color, 0.6, 50, Math.PI / 6);
        light.position.set(...pos);
        light.target.position.set(0, 3, 0);
        scene.add(light);
        scene.add(light.target);
    });

    // ==================== ç²’å­åœ£è¯æ ‘ ====================
    const treeParticles = [];
    const particleCount = 3500;

    function createEnhancedTree() {
        const treeLayers = [
            { yStart: 0, yEnd: 1.5, radiusTop: 0.4, radiusBottom: 0.5, color: 0x8B4513, density: 200 },
            { yStart: 1.5, yEnd: 3.5, radiusTop: 2.5, radiusBottom: 3.2, color: 0x0d4d0d, density: 800 },
            { yStart: 3.5, yEnd: 5.0, radiusTop: 2.0, radiusBottom: 2.5, color: 0x0f5f0f, density: 600 },
            { yStart: 5.0, yEnd: 6.5, radiusTop: 1.5, radiusBottom: 2.0, color: 0x1a7a1a, density: 500 },
            { yStart: 6.5, yEnd: 8.0, radiusTop: 1.0, radiusBottom: 1.5, color: 0x228b22, density: 400 },
            { yStart: 8.0, yEnd: 9.5, radiusTop: 0.3, radiusBottom: 1.0, color: 0x2d962d, density: 300 }
        ];

        const geometry = new THREE.BufferGeometry();
        const positions = [];
        const colors = [];
        const sizes = [];

        treeLayers.forEach(layer => {
            const layerHeight = layer.yEnd - layer.yStart;
            
            for (let i = 0; i < layer.density; i++) {
                const t = Math.random();
                const y = layer.yStart + t * layerHeight;
                const radius = layer.radiusBottom + (layer.radiusTop - layer.radiusBottom) * t;
                
                const angle = Math.random() * Math.PI * 2;
                const r = Math.random() * radius;
                const x = Math.cos(angle) * r;
                const z = Math.sin(angle) * r;
                
                positions.push(x, y, z);
                
                const color = new THREE.Color(layer.color);
                color.offsetHSL(0, 0, (Math.random() - 0.5) * 0.1);
                colors.push(color.r, color.g, color.b);
                
                sizes.push(0.08 + Math.random() * 0.05);
                
                treeParticles.push({
                    original: new THREE.Vector3(x, y, z),
                    velocity: new THREE.Vector3(0, 0, 0)
                });
            }
        });

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

        const material = new THREE.PointsMaterial({
            size: 0.1,
            vertexColors: true,
            transparent: true,
            opacity: 0.9,
            blending: THREE.AdditiveBlending,
            sizeAttenuation: true
        });

        const points = new THREE.Points(geometry, material);
        scene.add(points);
        return points;
    }

    const treePoints = createEnhancedTree();

    // ==================== è£…é¥°ç‰©ç³»ç»Ÿ ====================
    const decorations = [];

    function createOrnament(position, color, size = 0.25) {
        const geometry = new THREE.SphereGeometry(size, 16, 16);
        const material = new THREE.MeshStandardMaterial({
            color: color,
            metalness: 0.9,
            roughness: 0.1,
            emissive: color,
            emissiveIntensity: 0.4
        });
        const ornament = new THREE.Mesh(geometry, material);
        ornament.position.copy(position);
        ornament.castShadow = true;
        ornament.userData.floatOffset = Math.random() * Math.PI * 2;
        scene.add(ornament);
        return ornament;
    }

    function createStar(position, size = 0.5) {
        const shape = new THREE.Shape();
        for (let i = 0; i < 10; i++) {
            const angle = (i / 10) * Math.PI * 2 - Math.PI / 2;
            const radius = i % 2 === 0 ? size : size * 0.4;
            const x = Math.cos(angle) * radius;
            const y = Math.sin(angle) * radius;
            if (i === 0) shape.moveTo(x, y);
            else shape.lineTo(x, y);
        }

        const extrudeSettings = { depth: 0.15, bevelEnabled: true, bevelThickness: 0.02 };
        const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
        const material = new THREE.MeshStandardMaterial({
            color: 0xffff00,
            emissive: 0xffaa00,
            emissiveIntensity: 1,
            metalness: 1,
            roughness: 0
        });

        const star = new THREE.Mesh(geometry, material);
        star.position.copy(position);
        star.castShadow = true;
        scene.add(star);
        
        const pointLight = new THREE.PointLight(0xffff00, 2, 5);
        pointLight.position.copy(position);
        scene.add(pointLight);
        star.userData.light = pointLight;
        
        return star;
    }

    function createBell(position) {
        const group = new THREE.Group();
        
        const bodyGeo = new THREE.CylinderGeometry(0.12, 0.18, 0.25, 16, 1, true);
        const bodyMat = new THREE.MeshStandardMaterial({
            color: 0xFFD700,
            metalness: 0.95,
            roughness: 0.05
        });
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        
        const topGeo = new THREE.SphereGeometry(0.06, 16, 16);
        const top = new THREE.Mesh(topGeo, bodyMat);
        top.position.y = 0.15;
        
        const clapperGeo = new THREE.SphereGeometry(0.04, 8, 8);
        const clapper = new THREE.Mesh(clapperGeo, bodyMat);
        clapper.position.y = -0.08;
        
        group.add(body, top, clapper);
        group.position.copy(position);
        group.castShadow = true;
        group.userData.swingOffset = Math.random() * Math.PI * 2;
        scene.add(group);
        return group;
    }

    function createBow(position) {
        const group = new THREE.Group();
        const material = new THREE.MeshStandardMaterial({
            color: 0xff1744,
            metalness: 0.2,
            roughness: 0.8
        });

        const wingGeo = new THREE.TorusGeometry(0.18, 0.07, 12, 24, Math.PI);
        
        const leftWing = new THREE.Mesh(wingGeo, material);
        leftWing.rotation.y = Math.PI / 2;
        leftWing.rotation.z = -Math.PI / 6;
        leftWing.position.set(-0.12, 0, 0);
        
        const rightWing = new THREE.Mesh(wingGeo, material);
        rightWing.rotation.y = -Math.PI / 2;
        rightWing.rotation.z = Math.PI / 6;
        rightWing.position.set(0.12, 0, 0);
        
        const centerGeo = new THREE.SphereGeometry(0.08, 16, 16);
        const center = new THREE.Mesh(centerGeo, material);
        
        const ribbonGeo = new THREE.BoxGeometry(0.04, 0.3, 0.04);
        const ribbon1 = new THREE.Mesh(ribbonGeo, material);
        ribbon1.position.y = -0.15;
        ribbon1.rotation.z = 0.2;
        
        const ribbon2 = new THREE.Mesh(ribbonGeo, material);
        ribbon2.position.y = -0.15;
        ribbon2.rotation.z = -0.2;
        
        group.add(leftWing, rightWing, center, ribbon1, ribbon2);
        group.position.copy(position);
        group.castShadow = true;
        scene.add(group);
        return group;
    }

    function addAllDecorations() {
        decorations.push(createStar(new THREE.Vector3(0, 10, 0), 0.6));

        const ballColors = [0xff0000, 0x0000ff, 0xffd700, 0xff69b4, 0x00ff00, 0xff8c00];
        for (let i = 0; i < 18; i++) {
            const layer = 2.5 + Math.random() * 6;
            const maxRadius = (10 - layer) / 3.5;
            const angle = (i / 18) * Math.PI * 2 + Math.random() * 0.5;
            const radius = maxRadius * (0.6 + Math.random() * 0.4);
            
            const pos = new THREE.Vector3(
                Math.cos(angle) * radius,
                layer,
                Math.sin(angle) * radius
            );
            const color = ballColors[Math.floor(Math.random() * ballColors.length)];
            decorations.push(createOrnament(pos, color, 0.2 + Math.random() * 0.15));
        }

        for (let i = 0; i < 8; i++) {
            const layer = 3 + Math.random() * 5;
            const maxRadius = (10 - layer) / 3.5;
            const angle = (i / 8) * Math.PI * 2;
            const radius = maxRadius * 0.7;
            
            const pos = new THREE.Vector3(
                Math.cos(angle) * radius,
                layer,
                Math.sin(angle) * radius
            );
            decorations.push(createBell(pos));
        }

        for (let i = 0; i < 10; i++) {
            const layer = 2.5 + Math.random() * 6;
            const maxRadius = (10 - layer) / 3.5;
            const angle = (i / 10) * Math.PI * 2 + 0.3;
            const radius = maxRadius * 0.8;
            
            const pos = new THREE.Vector3(
                Math.cos(angle) * radius,
                layer,
                Math.sin(angle) * radius
            );
            decorations.push(createBow(pos));
        }
        
        document.getElementById('decorations').textContent = decorations.length;
    }

    addAllDecorations();

    // ==================== é¼ æ ‡äº¤äº’ ====================
    let mousePosition = new THREE.Vector3(0, 5, 5);
    let isMouseMoving = false;

    const handIndicator = new THREE.Mesh(
        new THREE.SphereGeometry(0.3, 32, 32),
        new THREE.MeshBasicMaterial({
            color: 0xff00ff,
            transparent: true,
            opacity: 0.6,
            blending: THREE.AdditiveBlending
        })
    );
    scene.add(handIndicator);

    // é¼ æ ‡æ§åˆ¶
    const customCursor = document.getElementById('customCursor');
    document.addEventListener('mousemove', (e) => {
        // æ›´æ–°è‡ªå®šä¹‰é¼ æ ‡ä½ç½®
        customCursor.style.left = e.clientX - 15 + 'px';
        customCursor.style.top = e.clientY - 15 + 'px';
        customCursor.style.transform = 'scale(1.2)';
        
        // æ˜ å°„åˆ°3Dç©ºé—´
        const x = (e.clientX / window.innerWidth) * 2 - 1;
        const y = -(e.clientY / window.innerHeight) * 2 + 1;
        
        mousePosition.set(x * 12, y * 10 + 5, 5);
        isMouseMoving = true;
        
        setTimeout(() => {
            customCursor.style.transform = 'scale(1)';
        }, 100);
    });

    document.addEventListener('mouseleave', () => {
        isMouseMoving = false;
    });

    // ==================== ç²’å­äº¤äº’ ====================
    function updateParticles() {
        const positions = treePoints.geometry.attributes.position.array;
        
        for (let i = 0; i < treeParticles.length; i++) {
            const particle = treeParticles[i];
            const index = i * 3;
            
            const current = new THREE.Vector3(
                positions[index],
                positions[index + 1],
                positions[index + 2]
            );
            
            if (isMouseMoving) {
                const distance = current.distanceTo(mousePosition);
                
                if (distance < 4) {
                    const force = new THREE.Vector3()
                        .subVectors(current, mousePosition)
                        .normalize()
                        .multiplyScalar(0.4 / Math.max(distance, 0.3));
                    
                    particle.velocity.add(force);
                }
            }
            
            const restore = new THREE.Vector3()
                .subVectors(particle.original, current)
                .multiplyScalar(0.06);
            
            particle.velocity.add(restore);
            particle.velocity.multiplyScalar(0.90);
            
            current.add(particle.velocity);
            
            positions[index] = current.x;
            positions[index + 1] = current.y;
            positions[index + 2] = current.z;
        }
        
        treePoints.geometry.attributes.position.needsUpdate = true;
    }

    // ==================== åŠ¨ç”»å¾ªç¯ ====================
    const clock = new THREE.Clock();
    let frameCount = 0;
    let lastTime = performance.now();
    
    function animate() {
        requestAnimationFrame(animate);
        const time = clock.getElapsedTime();
        
        updateParticles();
        
        if (isMouseMoving) {
            handIndicator.position.copy(mousePosition);
            handIndicator.scale.setScalar(1 + Math.sin(time * 5) * 0.2);
        }
        
        decorations.forEach((dec, i) => {
            if (dec.userData.light) {
                dec.rotation.y = time * 0.5;
                dec.userData.light.intensity = 2 + Math.sin(time * 3) * 0.5;
            } else if (dec.userData.floatOffset !== undefined) {
                const offset = dec.userData.floatOffset;
                dec.position.y += Math.sin(time * 2 + offset) * 0.001;
                dec.rotation.y += 0.01;
            } else if (dec.userData.swingOffset !== undefined) {
                const offset = dec.userData.swingOffset;
                dec.rotation.z = Math.sin(time * 2 + offset) * 0.1;
            } else {
                dec.rotation.y = time * 0.3 + i;
            }
        });
        
        treePoints.rotation.y = time * 0.05;
        
        renderer.render(scene, camera);
        
        // FPS è®¡ç®—
        frameCount++;
        const currentTime = performance.now();
        if (currentTime >= lastTime + 1000) {
            document.getElementById('fps').textContent = frameCount;
            frameCount = 0;
            lastTime = currentTime;
        }
    }

    // ==================== å¯åŠ¨ ====================
    document.getElementById('loading').style.display = 'none';
    console.log('âœ… åœ£è¯æ ‘åŠ è½½å®Œæˆ');
    animate();

    // ==================== å“åº”å¼ ====================
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
    </script>
</body>
</html>
